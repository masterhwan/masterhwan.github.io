<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-31T08:01:37.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>20181031</title>
    <link href="http://yoursite.com/2018/10/31/20181031/"/>
    <id>http://yoursite.com/2018/10/31/20181031/</id>
    <published>2018-10-31T05:14:29.000Z</published>
    <updated>2018-10-31T08:01:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>playground project 정리</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;playground project 정리&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20181030</title>
    <link href="http://yoursite.com/2018/10/30/20181030/"/>
    <id>http://yoursite.com/2018/10/30/20181030/</id>
    <published>2018-10-30T13:40:03.000Z</published>
    <updated>2018-10-31T05:09:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Pasing"><a href="#Pasing" class="headerlink" title="Pasing"></a>Pasing</h1><ul><li><p>게시판 페이지 어떻게 나눌래?</p><ul><li>맨 처음에는 당연히 글을 다 불러와서 나누어서 보여줘야지 라는 생각을 가지고 있었다. 하지만 당연히 이런 비효율적인 답변은 기대하지<br>않았을테고</li><li>그래서 검색했다.<br><a href="https://docs.spring.io/spring-data/jpa/docs/1.7.2.RELEASE/reference/html/#_handlermethodargumentresolvers_for_pageable_and_sort" target="_blank" rel="noopener">https://docs.spring.io/spring-data/jpa/docs/1.7.2.RELEASE/reference/html/#_handlermethodargumentresolvers_for_pageable_and_sort</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">공식문서에는 두가지 방법이 나와있다</span><br><span class="line">Pageable 과 PageRequest</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;/list/&#123;매개변수들&#125;&quot;)</span><br><span class="line">public Page&lt;Article&gt; findFirst10ByJob(Pageable pageable, [매개변수들]) &#123;</span><br><span class="line">PageRequest pageRequest =</span><br><span class="line">new PageRequest(0, 10);</span><br><span class="line">return articleRepository.findAll(pageRequest);</span><br><span class="line">return articleRepository.findAll(pageRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Pageable은 인터페이스 PageRequest는 Pageable의 구현체이다.</p></li><li>PageRequest는 매개변수들을 받아서 인스턴트를 생성한 후 넘겨주면된다. 그런데 스프링에서 이제 Deprecated되서 사용하는 것을 비추한다.</li><li>Pageable은 더 쉽다. Html form에서 page, size, sort 값을<br>보내주면 자동으로 sql문을 생성해준다.</li></ul><p>size 기본값은 20인듯 하다.</p><p>너무 가볍개 구현해서 의심이 든다 내일 도서관에서 책이랑 같이 봐야 겠다.<br><img src="https://github.com/masterhwan/masterhwan.github.io/blob/master/2018/10/30/20181030/Screen%20Shot%202018-10-30%20at%2010.39.30%20PM.png?raw=true" alt=""><br><img src="https://github.com/masterhwan/masterhwan.github.io/blob/master/2018/10/30/20181030/Screen%20Shot%202018-10-30%20at%2010.39.35%20PM.png?raw=true" alt=""><br><img src="https://github.com/masterhwan/masterhwan.github.io/blob/master/2018/10/30/20181030/Screen%20Shot%202018-10-30%20at%2011.12.44%20PM.png?raw=true" alt=""><br><img src="https://github.com/masterhwan/masterhwan.github.io/blob/master/2018/10/30/20181030/Screen%20Shot%202018-10-30%20at%2011.12.56%20PM.png?raw=true" alt=""><br><img src="https://github.com/masterhwan/masterhwan.github.io/blob/master/2018/10/30/20181030/Screen%20Shot%202018-10-31%20at%201.52.51%20PM.png?raw=true" alt=""><br><img src="https://github.com/masterhwan/masterhwan.github.io/blob/master/2018/10/30/20181030/Screen%20Shot%202018-10-31%20at%201.52.38%20PM.png?raw=true" alt=""><br><img src="https://github.com/masterhwan/masterhwan.github.io/blob/master/2018/10/30/20181030/Screen%20Shot%202018-10-31%20at%201.52.26%20PM.png?raw=true" alt=""></p><p>다음이나 네이버같은 곳은 앵커 태그가 아니라 자바스크립트로 처리하는듯 하다.</p><h1 id="RESTFUL-API"><a href="#RESTFUL-API" class="headerlink" title="RESTFUL API"></a>RESTFUL API</h1><ul><li>특징으로 클라이언트/서버 구조, 계층형 구조, 무상태성, 캐시, 코드 온 디맨드, 통합 인터페이스이 있다는 걸 알겠는데 여기서 나한테 와 닿는건 통합인터페이스 밖에 없다. 내가 웹서버와 was는 이미 무상태성을 지원하고, 내가 계층형 구조를 만드는게 아니라 이미 만들어진 구조를 가져다가 사용하고 있고, 내가 직접적으로 건드리는건 url을 통해서 데이터를 주고 받는 것만 하다보니깐 누가 <strong>RESTFUL API</strong>가 뭐냐고 물어보면 어떻게 답해야 하는지 모르겠다.</li></ul><p>엄마한테 생일 선물 좋은거 하고 싶었는데 아쉽</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Pasing&quot;&gt;&lt;a href=&quot;#Pasing&quot; class=&quot;headerlink&quot; title=&quot;Pasing&quot;&gt;&lt;/a&gt;Pasing&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;게시판 페이지 어떻게 나눌래?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;맨 처음에는 당연히 글을 다
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20181029</title>
    <link href="http://yoursite.com/2018/10/29/20181029/"/>
    <id>http://yoursite.com/2018/10/29/20181029/</id>
    <published>2018-10-29T04:53:25.000Z</published>
    <updated>2018-10-29T12:40:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>aws ec2 ubuntu 서버에 tomcat 설치<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.$ wget http://apache.tt.co.kr/tomcat/tomcat-8/v8.5.34/bin/apache-tomcat-8.5.34.tar.gz</span><br><span class="line">확장자가 tar.gz인걸로 받으면 된다.</span><br><span class="line">2. 환경변수 잡기</span><br></pre></td></tr></table></figure></p><p>tomcat/bin/webapps/하위 디렉토리들 : 독립된 웹 애플리케이션<br><img src="https://github.com/masterhwan/masterhwan.github.io/blob/master/2018/10/29/20181029/Screen%20Shot%202018-10-29%20at%206.48.04%20PM.png?raw=true" alt=""></p><p>ROOT 디렉토리 : 도메인:8080로 접속하면 제공됨</p><p>tomcat log 보는 법<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/tomcat/logs 에서</span><br><span class="line">$ tail -500f catalina.xxx.log</span><br></pre></td></tr></table></figure></p><p>tomcat 시작하고 종료하기<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">시작</span><br><span class="line">~/tomcat/bin 에서</span><br><span class="line">$ ./startup.sh</span><br><span class="line">종료</span><br><span class="line">$ ./shutdown.sh</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;aws ec2 ubuntu 서버에 tomcat 설치&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20181028</title>
    <link href="http://yoursite.com/2018/10/28/20181028/"/>
    <id>http://yoursite.com/2018/10/28/20181028/</id>
    <published>2018-10-28T04:08:49.000Z</published>
    <updated>2018-10-28T07:46:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="책-알고리즘-문제-해결-전략"><a href="#책-알고리즘-문제-해결-전략" class="headerlink" title="책 : 알고리즘 문제 해결 전략"></a>책 : <a href="http://www.yes24.co.kr/24/goods/8006522" target="_blank" rel="noopener">알고리즘 문제 해결 전략</a></h1><h2 id="자주하는-실수"><a href="#자주하는-실수" class="headerlink" title="자주하는 실수"></a>자주하는 실수</h2><pre><code>1. 산술 오버플로2. 배열 범위 밖 원소에 접근3. 일관되지 않은 범위 표현 방식 사용하기4. Off-by-one 오류5. 컴파일러가 잡아주지 못하는 상수 오타6. 스택 오버플로7. 다차원 배열 인덱스 순서 바꿔 쓰기8. 잘못된 비교 함수 작성9. 최소, 최대 예외 잘못 다루기10. 연산자 우선순위 잘못 쓰기11. 너무 느린 입출력 방식 선택12. 변수 초기화 문제</code></pre><h2 id="디버깅과-테스팅"><a href="#디버깅과-테스팅" class="headerlink" title="디버깅과 테스팅"></a>디버깅과 테스팅</h2><ul><li>디버깅<ul><li>작은 입력에 대해 제대로 실행되나 확인하기</li><li>Aseertion(단정문) 사용</li><li>프로그램의 계산 중간 결과를 출력</li></ul></li></ul><h2 id="알고리즘의-시간-복잡도-분석"><a href="#알고리즘의-시간-복잡도-분석" class="headerlink" title="알고리즘의 시간 복잡도 분석"></a>알고리즘의 시간 복잡도 분석</h2><ul><li>계산 복잡도 이론 : 빠른 알고리즘이 존재 한다 = 쉬운 문제</li><li>P 문제 : 다항 시간 알고리즘이 존재하는 문제들의 알고리즘의 집합 </li><li>계산 복잡도 클래스 : 같은 성질을 갖는 문제들을 모아놓은 집합</li><li>NP : 다항 시간 알고리즘이 존재하지 않는 문제들의 집합이 아니다</li><li>이게 다 대체 무슨말이야</li><li>마스터 정리<ul><li>어떤 함수의 수행 시간이 특정 형태로 함수로 표현될 때 이함수의 O()표기법을 쉽게 계산할 수 있도록 도와줌<br><a href="https://github.com/be4ter/algorithm/blob/master/test/SumTest.java" target="_blank" rel="noopener">참고</a></li></ul></li></ul><h2 id="알고리즘의-정당성-증명"><a href="#알고리즘의-정당성-증명" class="headerlink" title="알고리즘의 정당성 증명"></a>알고리즘의 정당성 증명</h2><ul><li>귀납법<ul><li>단계 나누기 : 증명하고 싶은 사실을 여러 단계로 나눈다.</li><li>첫 단계 증명 : 그중 첫 단계에서 증명하고 싶은 내용이 성립함을 보인다.</li><li>귀납 증명 : 한 단계에서 증명하고 싶은 내용이 성립한다면, 다음 단계에서도 성립함을 보인다.</li></ul></li><li><p>반복문 불변식 : 반복문의 내용이 한 번 실행될 때마다 중간 결과가 우리가 원하는 답으로 가는 길 위에 잘 있는지 명시하는 조건</p><ul><li>반복문 진입시에 불변식이 성립함을 보인다.</li><li>반복문 내용이 시작할 때 불변식이 성립했다면 내용이 끝날 때도 불변식이 항상 성립함을 보인다.</li><li>반복문 종료시에 불변식이 성립하면 항상 우리가 정답을 구했음을 보인다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// (*) 불변식은 여기서 성립해야한다</span><br><span class="line">while(어떤조건) &#123;</span><br><span class="line">    // 반복문 내용의 시작</span><br><span class="line">    ...</span><br><span class="line">    // 반복문 내용의 끝</span><br><span class="line">    //(**) 불변식은 여기에서도 성립해야 한다.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>귀류법</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;책-알고리즘-문제-해결-전략&quot;&gt;&lt;a href=&quot;#책-알고리즘-문제-해결-전략&quot; class=&quot;headerlink&quot; title=&quot;책 : 알고리즘 문제 해결 전략&quot;&gt;&lt;/a&gt;책 : &lt;a href=&quot;http://www.yes24.co.kr/24/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20181027</title>
    <link href="http://yoursite.com/2018/10/27/20181027/"/>
    <id>http://yoursite.com/2018/10/27/20181027/</id>
    <published>2018-10-27T11:52:47.000Z</published>
    <updated>2018-10-27T11:53:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>알고리즘 셤  = 탈락</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;알고리즘 셤  = 탈락&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="알고리즘" scheme="http://yoursite.com/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
  </entry>
  
  <entry>
    <title>20181026</title>
    <link href="http://yoursite.com/2018/10/26/20181026/"/>
    <id>http://yoursite.com/2018/10/26/20181026/</id>
    <published>2018-10-26T02:21:37.000Z</published>
    <updated>2018-10-27T06:25:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="책-스프링부트로-배우는-웹-개발-알고리즘-문제-해결-전략"><a href="#책-스프링부트로-배우는-웹-개발-알고리즘-문제-해결-전략" class="headerlink" title="책 :스프링부트로 배우는 웹 개발 | 알고리즘 문제 해결 전략"></a>책 :<a href="http://www.yes24.com/24/goods/61793313" target="_blank" rel="noopener">스프링부트로 배우는 웹 개발</a> | <a href="http://www.yes24.co.kr/24/goods/8006522" target="_blank" rel="noopener">알고리즘 문제 해결 전략</a></h1><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><ul><li>API문서화 : Swagger<ul><li>web 개발하기 전에 추가하기</li></ul></li><li>RestTemplate<ul><li>REST API와 연동 시에는 HTTP 요청을 보내는 것 뿐만 아니라 실제로 응답에 JSON데이터를 파싱하고 모델 객체와 매핑하는 것이 중유</li></ul></li><li>UtiComponentBuilder<ul><li>다양한 API와 URL을 매핑하기 위해서 문자열로 조합하다 보면 가독성이 떨어져서 유지보수가 힘들다.</li><li>Builder 방식으로 uri를 만드는데 필요한 정보들을 메서드를 이용해 만들수 있고, 인코딩도 가능하다.</li><li>RestTemplate을 이용해서 POST 방식으로 데이터를 요청할 때에는 MultiValueMap을 사용해서 데이터를 전달해야하는데, UriComponentBuilder는 자동으로 변환한다.</li></ul></li><li>HTTP 메서드별 RestTemplate 메서드 명세<br>  |메서드명| HTTP 호출방식 | 변환 타입|<br>  |—|—|—|<br>  |getForObject| GET | Object|<br>  |getForEntity| GET | HttpResponseEntity|<br>  |postForObject| POST | Object |<br>  |postForEntity| POST | HttpResponseEntity |<br>  |delete| DELETE | - |<br>  |put| PUT | -|<br>  |exchange| user-define | user-define|</li><li>Rest와 관련된 RestController, RestTemplate, UriComponentBuilder, ResponseEntity<br><a href="https://github.com/be4ter/intellij-projects/tree/practice-rest" target="_blank" rel="noopener">참고</a><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2></li><li><p>ORM : Object와 Relation 간의 불일치 문제를 해결하기 위한 도구.</p><pre><code>자바에서는 JDBC API로 데이터베이스 제어가 가능하지만 ORM을 사용하는 이유는 로직 처리를 SQL로 하게 되고, 자바의 언어적인 기능을 사용하기 보다는 쿼리와 결과를 매핑하는 용도로 사용하게 되기 때문에</code></pre></li><li><p>spring data : NOSQL, RDBMS 어느 한쪽만을 목표로 하지                        않으므로 추상화된 인터페이스를 통해 다양한 저장소를                 활용할 수 있다.</p></li><li><p>자바 제네릭에서 Type 표기 약어의 의미</p><ul><li>E : Element(요소를 의미)</li><li>K : Key(키를 의미)</li><li>N : Number(숫자를 의미)</li><li>T : Type(타입을 의미)</li><li>V : Value(값을 의미)</li></ul></li><li><p>@ManyToOne의 fetch 기본값은 EAGER(즉시 로딩)이므로 성능 향상을 위해 FetchType.LAZY(지연 로딩)으로 설정해주는게 좋다.</p></li><li><p>mapperBy : jpa 연관 관계에서 주인을 명시하기 위해 사용한다.<br>연관 관계의 주인은 다수 쪽이다.</p></li><li><p>QueryDSL : 다음에</p></li><li>Mybatis <ul><li>쿼리 매핑을 위해 sqlSession 객체 사용, sqlSession객체 생성에 sqlSessionFactory를 사용, spring과 같이 사용할때는 SqlSessionTemplate 사용 : 예외 처리를 spring에 DataAcessException으로 치환 시키기 때문에</li><li>‘%{}%’ 비슷한것 검색</li><li>#{} 한개 검색</li></ul></li><li>DataBase Connection Pool : 여러사람이 DB서버에 요청할 때마다 커넥션을 생성하면 서버 컴퓨터가 견디지 못해서 사용</li><li>Mybatis에서는 동적 SQL을 지원하지만 서비스 클래스에서 조건문을 활용해 먼저 처리하는 것이 좋다.<br><a href="https://github.com/be4ter/intellij-projects/tree/practice-db" target="_blank" rel="noopener">참고</a></li></ul><h2 id="프로그래밍을-위한-여섯-단계-문제-해결-알고리즘"><a href="#프로그래밍을-위한-여섯-단계-문제-해결-알고리즘" class="headerlink" title="프로그래밍을 위한 여섯 단계 문제 해결 알고리즘"></a>프로그래밍을 위한 여섯 단계 문제 해결 알고리즘</h2><pre><code>1. 문제를 읽고 이해한다.2. 문제를 익숙한 용어로 재정의한다.3. 어떻게 해결할지 계획을 세운다.4. 계획을 검증한다.5. 프로그램으로 구현한다.6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.</code></pre><h2 id="좋은코드를-작성하기-위한-원칙"><a href="#좋은코드를-작성하기-위한-원칙" class="headerlink" title="좋은코드를 작성하기 위한 원칙"></a>좋은코드를 작성하기 위한 원칙</h2><pre><code>1. 간결한 코드 작성2. 적극적으로 코드 재사용 하기    - 같은 코드가 세번 이상 등장하면 생각해보기3. 표준 라이브러리 공부하기4. 항상 같은 형태로 프로그램 작성하기5. 일관적이고 명료한 명명법 사용하기7. 모든 자료를 정규화해서 저장하기    - 클래스 생성자에서 정규화 수행6. 코드와 데이터를 분리하기</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;책-스프링부트로-배우는-웹-개발-알고리즘-문제-해결-전략&quot;&gt;&lt;a href=&quot;#책-스프링부트로-배우는-웹-개발-알고리즘-문제-해결-전략&quot; class=&quot;headerlink&quot; title=&quot;책 :스프링부트로 배우는 웹 개발 | 알고리즘 문제 해
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20181025</title>
    <link href="http://yoursite.com/2018/10/25/20181025/"/>
    <id>http://yoursite.com/2018/10/25/20181025/</id>
    <published>2018-10-25T04:07:19.000Z</published>
    <updated>2018-10-30T04:12:00.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>다시 블로그 시작</li></ul><h2 id="책-스프링부트로-배우는-웹-개발"><a href="#책-스프링부트로-배우는-웹-개발" class="headerlink" title="책 :스프링부트로 배우는 웹 개발"></a>책 :<a href="http://www.yes24.com/24/goods/61793313" target="_blank" rel="noopener">스프링부트로 배우는 웹 개발</a></h2><p>##1</p><ul><li>웹 서버 : html파일 같은 정적 파일들을 전달해 주는 역할을 하는 서버</li><li>웹 어플리케이션 컨테이너 = 웹 어플리케이션 서버<ul><li>php,jsp,asp,js 등 언어들 사용해서 동적인 페이지들이 생성 가능한 서버</li></ul></li><li>클래스 로더 : JVM에 class를 loading 한다<ul><li>계층 구조 : Bootstrap (최상위)-&gt; Extension -&gt; System -&gt; User-Define Class loader (최하위)</li><li>Bootstrap Class loader :  &lt;JAVA_HOME&gt;/jre/lib에 위치한 자바 핵심 라이브러리를 로딩</li><li>Extension Class loader : &lt;JAVA_HOME&gt;/jre/lib/ext또는 java.ext.dirs 시스템 속성에 지정된 기타 디렉터리의 코드를 로딩</li><li>System Class loader : ClassPath 환경변수에 매핑</li><li><a href="https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94" target="_blank" rel="noopener">https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94</a></li></ul></li><li>쿠키(Cookie) : 클라이언트의 상태 관리</li><li>세션(Session) : 서버의 상태 관리<br>##2</li><li>자바 웹 개발에서 IoC가 인기를 끄는 이유<ul><li>프로그램의 생명주기에 대한 주도권이 웹 애플리케이션 컨테이너에 있기 때문에</li></ul></li><li>IoC <ul><li>하이레벨 모듈은 로우레벨 모듈에 의존해서는 안 되고, 모두 인터페이스에 의존해야 한다.</li><li>추상화는 세부 사항에 의존해서는 안된다. 세부 사항이 추상화에 의존해야 한다.</li><li>= 인터페이스를 사용해 결합도 낮추는것이 목적</li><li>하지만 인터페이스 구현체가 필요해 완전히 분리할수 없다.</li><li>인스턴스화할 수 있는 코드에 대한 의존성을 해결하는 것이 <strong>의존성 주입</strong>이다.</li><li>인터셉터 : @Controller가 요청을 처리하기 전, 후에 대해 로직 추가 할수 있다<h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2></li></ul></li><li>REST(Representational State Transfer) : 분산 네트워크 프로그래밍의 아키텍쳐 스타일, 로이 필딩이 처음 제안</li><li>특징<ul><li>클라이언트/서버 : 클라이언트와 서버가 독립적으로 구분되어야하고,<br>서버 또는 클라이언트 증설 시에 서로간의 의존성 때문에 확장에 문제가 되는 일이 없어야 한다.</li><li>무상태성 : 클라이언트와 서버 간의 통신에 상태가 없어야한다. 서버는 클라이언트 상태를 기억할 필요가 없다.</li><li>계층형 구조 : 서버와 클라이언트 사이에 게이트웨어, 방화벽, 프록시가 있는 것처럼 다계층 형태로 레이어를 추가하거나 수정하거나 제거할 수 있어야 한다.</li><li>캐시 : 서버의 응답들은 캐시를 가지고 있거나 없거나 둘 중의 하나인데, 캐시를 가지고 있을 경우에는 클라이언트가 캐시를 통해서 응답을 재사용할 수 있고 이를 통해서 서버의 부하를 낮추어서 서버의 성능이 향상될 수 있다.</li><li>코드 온 디멘드 : 요청이 오면 코드를 준다는 의미로 특정 시점에 서버가 특정 기능을 수행하는 스크립트 또는 플러그인을 클라이언트에 전달해서 해당 기능을 동작하도록 하는 것이다. 예로는 애플릿, 자바스크립트, 플래시가 있다.</li><li>통합 인터페이스 : 서버와 클라이언트 간의 상호 작용은 일관된 인터페이스들 위에서 이뤄져야 한다. 그 내용은 아래와 같다.<ul><li>인터페이스 규칙<ul><li>리소스 식별 : 웹 안에서 서로 구분할 수 있는 개념으로 URI와 같은 고유 시별자를 통해 표현할 수 있다.</li><li>표현을 통한 리소스 처리 : 같은 데이터에 대해서 표현할 때 JSON, XML, HTML 페이지와 같이 다양한 콘텐츠 유형으로 표현할 수 있다. 그렇지만 데이터는 변경되지 않는다.</li><li>자기 묘사 메세지 : HTTP 통신을 할 때도 Header에 메타 데이터 정보를 추가해서 실제 데이터와는 관련 없지만 데이터에 대한 설명을 나타내는 정보를 담을수 있다.</li><li>애플리케이션의 상태에 대한 하이퍼미디어(HATEOS) : 웹은 여러 페이지들과 그 페이지들이 이동할 수있는 링크 정보들로 구성되어 있다. REST API를 개발할 때도 단순히 데이터만 전달하지 않고 링크 정보까지 포함한다면 좀 더 웹에 친숙한 REST API가 될 것이다.</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;다시 블로그 시작&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;책-스프링부트로-배우는-웹-개발&quot;&gt;&lt;a href=&quot;#책-스프링부트로-배우는-웹-개발&quot; class=&quot;headerlink&quot; title=&quot;책 :스프링부트로 배우는 웹 개발&quot;&gt;&lt;/a&gt;책 :&lt;
      
    
    </summary>
    
    
      <category term="til" scheme="http://yoursite.com/tags/til/"/>
    
  </entry>
  
</feed>
